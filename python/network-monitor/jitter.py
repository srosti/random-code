# License: AI generated code - use as you wish
# Shawn Rosti


import socket
import subprocess
import statistics
from pythonping import ping
from tkinter import Tk, Canvas, Scale
import time

# Define the maximum value for the gauge
MAX_VALUE = 100

def measure_rtt(host, port=80):
  """
  Measures the round trip time (RTT) to a specific host and port.

  Args:
      host: The hostname or IP address of the server.
      port: The port number of the server (default 80).

  Returns:
      The RTT in miliseconds as a float, or None if an error occurs.
  """
  try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
      start_time = time.time()
      sock.connect((host, port))
      end_time = time.time()
    return (end_time - start_time) * 1000
  except Exception as e:
    print(f"Error measuring RTT: {e}")
    return None



class UpdateWindow:
    def __init__(self, master):

        # Create the canvas for drawing the gauge
        self.canvas = Canvas(root, width=200, height=200)
        self.canvas.pack()

        # Create a scale widget to control the gauge value
        scale = Scale(root, from_=0, to=MAX_VALUE, orient="horizontal", command=self.update_gauge)
        scale.pack()
        self.update_gauge(50)

    def update_text(self):
        # Update the label text
        self.label.config(text="Updated text!")

        # Simulate some background work
        for i in range(10):
            # This loop can be replaced with actual background operation
            pass

        # Update the window after background work (optional)
        self.master.update()

    def update_gauge(self, value):
      """
      Updates the gauge based on the provided value.

      Args:
        value: The value to display on the gauge (0 to MAX_VALUE).
      """
      # Calculate the angle based on the value
      angle = (value / MAX_VALUE) * 270  # 270 degrees for full arc

      # Clear the previous gauge drawing
      self.canvas.delete("gauge")

      # Draw the gauge arc
      center_x, center_y = 100, 100  # Center of the gauge
      radius = 80  # Radius of the gauge
      start_angle = 135  # Starting angle (top center)
      arc_width = 20  # Width of the arc

      self.canvas.create_arc(
          center_x - radius,
          center_y - radius,
          center_x + radius,
          center_y + radius,
          start=start_angle,
          extent=-angle,
          width=arc_width,
          style="arc",
          tags="gauge",
          fill="#3498db"  # Adjust fill color as desired
      )

      # Display the current value in the center
      self.canvas.create_text(center_x, center_y, text=str(value), font=("Arial", 20), tags="gauge")

      self.canvas.update()


def measure_latency(host, count=5):
    """
    Measures average latency to a specified host using ICMP echo requests.

    Args:
    host: The hostname or IP address to ping.
    count: The number of packets to send (default: 5).

    Returns:
    The average latency in milliseconds, or None if no responses received.
    """

    MAX_PAYLOAD_SIZE=1400

#    responses = ping(host, count=count, size=MAX_PAYLOAD_SIZE, df=True, timeout=1)
    responses = ping(host)
    if responses:
        return responses.rtt_avg_ms
    else:
        return None

#experiment with scapy, so we don't have to scrap the "ping" output
#Fixed output generated by gemini
from scapy.all import *
import time
def measure_latency_scapy(host, count=5):
    """
    Measures average latency to a specified host using ICMP echo requests.

    Args:
        host: The hostname or IP address to ping.
        count: The number of packets to send (default: 5).

    Returns:
        The average latency in milliseconds, or None if no responses received.
    """

    total_latency = 0
    received_count = 0

    for i in range(count):
        packet = IP(dst=host)/ICMP()
        reply = sr1(packet, timeout=2, verbose=0)  # Send and receive a single packet

        if reply is not None:
            latency = (reply.time - packet.sent_time) * 1000  # Calculate latency in milliseconds
            total_latency += latency
            received_count += 1

    if received_count > 0:
        return round(total_latency / received_count, 2)
    else:
        return None


def measure_latency_jitter(host, count=50):
    """Measures latency and jitter to a specified host."""

    latencies = []
    for _ in range(count):
        try:
            # Use ping to measure latency
            result = subprocess.run(['ping', '-c', '1', host], capture_output=True, text=True)
            # srosti - modified to match the output of my version of ping
            latency_ms = int(float(result.stdout.splitlines()[1].split()[-2].split('=')[1]))
            latencies.append(latency_ms)
        except Exception as e:
            print(f"Error measuring latency: {e}")

    if latencies:
        average_latency = statistics.mean(latencies)
        jitter = statistics.stdev(latencies)
        print(f"Average latency to {host}: {average_latency:.2f} ms")
        print(f"Jitter: {jitter:.2f} ms")
    else:
        print("No valid latency measurements obtained.")


if __name__ == "__main__":

    # Create the main window
#    root = Tk()
#    root.title("Gauge Example")
#
#    app = UpdateWindow(root)
#
#    # Start the main event loop
#    root.mainloop()
#

    HISTORY_DEPTH = 2
    LATENCY_THRESHOLD = 100
    host = "8.8.8.8"  # Replace with the desired host
    average=0
    history = [0] * HISTORY_DEPTH

    index=0
    while True:
        mean_latency = 0
        # Other ways of measuring latency - Disabling python ping works well enough
        # measure_latency_jitter(host)
        # latency=measure_latency_scapy(host)
        # print(f"Average Latency (scapy)={latency}")
        latency=measure_latency(host)
        history[index % HISTORY_DEPTH] = latency
        index += 1
        if (index) >= HISTORY_DEPTH:
            mean_latency = int(statistics.mean(history))
            if mean_latency > LATENCY_THRESHOLD:
                print(f"Mean Latency = \033[31m {mean_latency} \033[0m")
            else:
                print(f"Mean Latency = {mean_latency}")
            index = 0

        # Example usage for round-trip time
        host = "www.google.com"
        rtt = measure_rtt(host)

        if rtt:
          print(f"Round trip time to {host}: {rtt:.2f} miliseconds")
        else:
          print(f"Failed to measure RTT to {host}")

        time.sleep(5)